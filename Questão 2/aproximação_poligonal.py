# -*- coding: utf-8 -*-
"""Aproximação poligonal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tCcRQuUdcoihkauCXh2LGIiS-o7mtFxi
"""

# aproxima_poligonal.py
# Requer: pip install opencv-python matplotlib numpy

!pip install opencv-python matplotlib numpy

import cv2
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# >>> Troque aqui pelo caminho da sua imagem (ex.: "Imagem Q2.png")
IMAGE_PATH = "/content/Imagem Q2.png"

# Fator de simplificação do polígono (0.01–0.03 são bons pontos de partida)
EPSILON_RATIO = 0.02

def main():
    # 1) Carregar imagem
    img = cv2.imread(IMAGE_PATH, cv2.IMREAD_COLOR)
    if img is None:
        raise FileNotFoundError(f"Não consegui abrir: {Path(IMAGE_PATH).resolve()}")

    # 2) Pré-processamento: cinza, blur e limiarização (Otsu)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5, 5), 0)
    # Se sua imagem já é binária, essa etapa ainda funciona (Otsu decide o limiar)
    _, bin_ = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # Opcional: fechar pequenos buracos e reduzir ruído
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    bin_clean = cv2.morphologyEx(bin_, cv2.MORPH_CLOSE, kernel, iterations=1)

    # 3) Contornos externos e seleção do maior (objeto principal)
    cnts, _ = cv2.findContours(bin_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        raise RuntimeError("Nenhum contorno encontrado. Verifique o threshold/morfologia.")
    largest = max(cnts, key=cv2.contourArea)

    # 4) Aproximação poligonal (Ramer–Douglas–Peucker)
    peri = cv2.arcLength(largest, True)
    epsilon = EPSILON_RATIO * peri
    approx = cv2.approxPolyDP(largest, epsilon, True)

    # 5) Desenhar resultados
    overlay_contour = img.copy()
    overlay_poly = img.copy()
    cv2.drawContours(overlay_contour, [largest], -1, (0, 255, 255), 2)  # contorno original (amarelo)
    cv2.drawContours(overlay_poly, [approx], -1, (0, 0, 255), 3)        # polígono aproximado (vermelho)

    # 6) Exibir lado a lado
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    cont_rgb = cv2.cvtColor(overlay_contour, cv2.COLOR_BGR2RGB)
    poly_rgb = cv2.cvtColor(overlay_poly, cv2.COLOR_BGR2RGB)

    plt.figure(figsize=(12, 8))
    plt.subplot(2, 2, 1); plt.imshow(img_rgb); plt.title("Original"); plt.axis("off")
    plt.subplot(2, 2, 2); plt.imshow(bin_clean, cmap="gray"); plt.title("Binária (limiar + close)"); plt.axis("off")
    plt.subplot(2, 2, 3); plt.imshow(cont_rgb); plt.title("Contorno maior"); plt.axis("off")
    plt.subplot(2, 2, 4); plt.imshow(poly_rgb); plt.title(f"Aproximação poligonal (ε={EPSILON_RATIO:.2%}·perímetro)"); plt.axis("off")
    plt.tight_layout()
    plt.show()

    # 7) Salvar arquivos
    out1 = Path(IMAGE_PATH).with_name("contorno_maior.png")
    out2 = Path(IMAGE_PATH).with_name("aprox_poligonal.png")
    cv2.imwrite(str(out1), overlay_contour)
    cv2.imwrite(str(out2), overlay_poly)
    print(f"[OK] Salvo: {out1}")
    print(f"[OK] Salvo: {out2}")

if __name__ == "__main__":
    main()